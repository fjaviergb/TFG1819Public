import json
#VER APARTADO 3.1 PARA SU EXPLICACION
import time
#VER APARTADO 3.1 PARA SU EXPLICACION
import paho.mqtt.client as mqtt
#VER APARTADO 3.3 PARA SU EXPLICACION
import threading
#VER APARTADO 3.1 PARA SU EXPLICACION
import sys
#VER APARTADO 3.1 PARA SU EXPLICACION

def on_message (client, userdata, msg): 
#FUNCION QUE RECIBE EL MENSAJE PROVENIENTE DEL SERVIDOR CONECTADO Y LO GUARDA
#EN LA VARIABLE msg, CON FORMATO JSON. ADEMAS, RECIBE INFORMACION ADICIONAL
#SOBRE EL INTERCAMBIO, PERO NO NOS INTERESA PORQUE ES ENTRE NOSOTROS MISMOS
    
     global data_IOTA
     #DECLARANDO LA VARIABLE COMO GLOBAL, NO TENDREMOS PROBLEMAS AL EJECUTAR
     #DOS BUCLES SIMULTANEAMENTE RELACIONADOS CON SOLAPE DE INFORMACION
     first_time()
     #LLAMADA A UNA FUNCION SIN ENTRADAS. ES LA ENCARGADA DE INICIAR LA FUNCION
     #DAEMON QUE ACTUARA COMO CONTADOR

     data_DICT=json.loads(msg.payload)
     #LA FUNCION .loads CONVIERTE UN DATO JSON EN UN DICT.
     
     if data_IOTA != {}:
     #CONDICIONAL QUE COMPRUEBA SI NO ES EL PRIMER DATO DE data_IOTA. SI NO LO
     #ES, LA INFORMACION ENTRANTE SE ADJUNTA A LA INFORMACION YA EXISTENTE
     
         for key in data_DICT.keys():
         #BUCLE QUE ORGANIZA LA INFORMACION QUE SE GUARDA EN LA VARIABLE. ITERA
         #POR CADA KEY DEL DICT Y LE ANNADE EL VALOR DEL NUEVO DATO CORRESPONDIENTE
             data_IOTA[key].append(data_DICT[key][0])
             
     if data_IOTA == {}:
     #CONDICIONAL QUE COMPRUEBA SI NO ES EL PRIMER DATO DE data_IOTA. SI LO ES,
     #EL DICT COMPLETO PASA A SER EL NUEVO DATO, AL QUE POSTERIORMENTE SE LE
     #ADJUNTARA MÁS INFORMACIÓN
         data_IOTA = data_DICT

def first_time():
#FUNCION QUE COMPRUEBA SI SE TRATA DE LA PRIMERA VEZ QUE SE RECIBE UN MENSAJE
#EN TODA LA CONEXIÓN. ES, POR TANTO, LA ENCARGADA DE INCIAR LA FUNCION DAEMON
#QUE ACTUARA DE TEMPORIZADOR PARA LA RECOPILACION DE LA INFORMACION.
    global first, bucle
    #SE DECLARAN GLOBALES PARA CAMBIAR EL VALOR EN TODO EL PROGRAMA, YA QUE
    #ENTRARA EN UN BUCLE INFINITO
    
    if first==True:
    #CONDICIONAL QUE SE CUMPLE UNA UNICA VEZ, YA QUE POSTERIORMENTE CAMBIA EL
    #VALOR DE first EN TODO EL MENSAJE
        bucle.start()
        #ESTA FUNCION DA COMIENZO A LA FUNCION SENNALADA POR BUCLE. LLAMAR DE 
        #NUEVO A ESTA FUNCION DARIA ERROR, DE AHI LA NECESIDAD DE LLAMARLA
        #SOLO UNA VEZ CON ESTA FUNCION
        first=False

def WAIT():
#FUNCION DAEMON QUE SE EJECUTARA EN SEGUNDO PLANO UNA VEZ SE RECIBA EL PRIMER
#MENSAJE DESDE EL SERVIDOR. SE ENCARGA DE CONTAR HASTA 10 Y LANZAR LA FUNCION
#save_FILE().
    
    global stop
    #SE DECLARA GLOBAL PORQUE EN LA FUNCION main() SE MODIFICA EL VALOR DE STOP
    #AL INTERRUMPIR POR TECLADO LA EJECUCIÓN DEL PROGRAMA
    
    while stop==True:
    #BUCLE INFINITO QUE SE EJECUTARA EXCEPTO QUE CAMBIE EL VALOR DE stop
        time.sleep(10)
        #CONTADOR DE 10 SEGUNDOS
        save_FILE()
        #LLAMADA A LA FUNCION ENCARGADA DE CREAR UN DOCUMENTO CON TODA LA INFO
        #RECOPILADA DURANTE LOS 10 SEGUNDOS. 

def save_FILE():
#FUNCION ENCARGADA DE CREAR EL DOCUMENTO DONDE SE GUARDA LA INFORMACION 
#RECOPILADA. EN EL CICLO DE VIDA DE UNA TRANSACCION SE PUEDE VER UN EJEMPLO
    
    global data_IOTA
    #DECLARA GLOBAL LA VARIABLE PORQUE LUEGO LA MODIFICA BORRANDO SU VALOR
    #UNA VEZ HA GUARDADO LA VARIABLE EN UN DOCUMENTO
    
    file_name = str(time.time())
    #EL NOMBRE DEL DOCUMENTO SERA EL TIEMPO UNIX EN EL QUE SE CREA EL FICHERO.
    #DE ESTA MANERA, SE PUEDE ORDENAR POR DURACIÓN Y HACER REFERENCIA AL MISMO.
    #ESA FUNCION SE EXPLICA EN DESARROLLO: Iota.
    
    path='/home/pi/Documents/FJavierGb/DATOSRPICTV/'+file_name+'.txt'
    db = open(path,'a+')
    db.write(str(data_IOTA))
    db.close()
    #METODO EMPLEADO PARA ABRIR UN ARCHIVO DE TEXTO NOMBRADO CON EL TIEMPO MEDIDO, 
    #GUARDAR EL DICT COMO UN STRING Y CERRARLO.
    #ES CONVERTIDA A STRING PARA FACILITAR POSTERIORMENTE SU ENCRIPTACION
    data_IOTA = {}
    #UNA VEZ GUARDADA LA INFORMACION, REINICIA EL VALOR DEL DICT

def on_connect(client, userdata, flags, rc):
#FUNCION QUE PERMITE ACTIVAR LA SUSCRIPCION A UN TOPIC DETERMINADO UNA UNICA
#VEZ. SI FUERAMOS A SUSCRIBIRNOS AL MISMO TOPIC DOS VECES, SALTARIA UN ERROR
#QUE INTERRUMPIRIA LA EJECUCION DEL PROGRAMA
    global MQTT_TOPIC, QOS
    client.subscribe(MQTT_TOPIC, qos=QOS)
    #ESTA FUNCION PERMITE DETERMINAR EL TOPIC DEL QUE EL CLIENTE ESPERA 
    #RECIBIR MENSAJES Y ESPECIFICA EL QOS DEL INTERCAMBIO
    
def main():
#FUNCION PRINCIPAL. SIEMPRE SE LLAMA Y EXISTE PARA DAR MAYOR GRANULIDAD AL 
#SCRIPT, MEJORANDO SU ENTENDIMIENTO Y EL ANALISIS DE ERRORES.
    
    global stop, bucle, MQTT_TOPIC, QOS
    #SE DECLARA COMO GLOBAL PORQUE LA INTERRUPCION DE LA FUNCION MAIN CAMBIARA
    #EL VALOR DE LA VARIABLE QUE PROVOCA QUE LA FUNCION WAIT() SEA INFINITA
    
    MQTT_BROKER ="localhost"
    #VARIABLE QUE GUARDA LA LOCALIZACION DEL SERVIDOR MQTT
    MQTT_TOPIC = "RPICT3V1"
    #VARIABLE QUE GUARDA EL TOPIC DEL QUE SE VAN A LEER LOS MENSAJES
    QOS = 0
    #EL QOS (VER APARTADO 3.3) DE MENOR NIVEL PARA FAVORECER LA RAPIDEZ Y EL
    #RENDIMIENTO, SACRIFICANDO FIABILIDAD Y SEGURIDAD.
    CLEAN_SESSION = True
    #VARIABLE QUE, CUANDO SE EMPLEE EN LA FUNCION ADECUADA, IMPLICA QUE 
    #EL SUBSCRIPTOR DEL TOPIC NO RECIBIRA POSIBLES MENSAJES ALMACENADOS  
    client = mqtt.Client('Receptor',CLEAN_SESSION) 
    #FUNCION QUE DEFINE AL CLIENTE. EN ESTE CASO VAMOS A LLAMARLO RECEPTOR Y
    #LA UNICA PROPIEDAD QUE INTERESA ACLARAR ES EL CLEAN SESSION
    
    try:
    #BUCLE INFINITO QUE PERMITE LA RECEPCION CONSTANTE DE DATOS DEL EMISOR
        bucle=threading.Thread(target=WAIT)
        #FUNCION QUE PERMITE HACER OBJETIVO A OTRA FUNCION Y EJECUTARLA EN
        #SEGUNDO PLANO (DAEMON)
        client.on_message = on_message 
        #LA FUNCION .on_message SE ACTIVA CUANDO EL CLIENTE SUSCRITO A UN
        #TOPIC RECIBE UN MENSAJE. ESTA ACTIVACION LLAMA A LA FUNCION on_message 
        #Y LE PASA COMO INPUTS EL MENSAJE COMO TAL (msg)
        client.on_connect = on_connect
        #LA FUNCION .on_connect SE ACTIVA CUANDO EL CLIENTE AVISA AL BROKER
        #SOBRE SU CONEXION. ESTA ACTIVACION LLAMA A LA FUNCION on_connect 
        #Y LE PASA COMO INPUTS INFORMACION DEL USUARIO
        client.connect(MQTT_BROKER, 1883, 60) #HOST + Puerto + KeepAlive.
        #FUNCION QUE CONECTA AL CLIENTE CON EL SERVIDOR LOCAL, PREVIAMENTE INSTALADO
        #EN LA RASPBERRY. EL PUERTO ES EL DEDICADO A LA RED LOCAL Y SE INDICA 1
        #MINUTO PARA VERIFICAR LA CORRECTA CONEXION ENTRE CLIENTE Y SERVIDOR.
        client.loop_forever()
        #FUNCION QUE PERMITE AL CLIENTE MANTENERSE CONECTADO INDEFINIDAMENTE
        
    except KeyboardInterrupt:
        stop = False
        #CUANDO SE INTERRUMPE POR TECLADO, SE CAMBIA LA VARIABLE stop, QUE ES
        #LA ENCARGADA DE CORTAR LA FUNCION WAIT()
        bucle.join()
        #FUNCION QUE PROVOCA QUE bucle NO APUNTE MAS A LA FUNCION WAIT()
        print('Interrumpido')
        sys.exit()  
    
data_IOTA = {}
first=True
stop=True
#SE INICIAN TRES VARIABLES QUE MODIFICAN SU VALOR A LO LARGO DE LA EJECUCION, 
#Y QUE SON NECESARIAS DEBIDO A LAS FUNCIONES DAEMON DEL PROGRAMA. SE LES DA
#UN VALOR INICIAL PORQUE EL PROGRAMA NO PASARÁ NUNCA MÁS POR AQUI.

main()
#LLAMADA A FUNCION MAIN. SIEMPRE VA A OCURRIR; EL PROGRAMA SE ENCIERRA EN 
#FUNCIONES PARA MEJORAR EL CONTROL DEL SCRIPT