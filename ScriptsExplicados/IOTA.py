from iota import Address, ProposedTransaction, Tag, Iota, TryteString
#MODULOS NECESARIOS DE LA API DE IOTA
import time
#VER APARTADO 3.1 PARA SU EXPLICACION
import pandas as pd
#VER APARTADO 3.1 PARA SU EXPLICACION
import sys
#VER APARTADO 3.1 PARA SU EXPLICACION
import os
#VER APARTADO 3.1 PARA SU EXPLICACION
from Crypto.PublicKey import RSA
#MODULO NECESARIO PARA ENCRIPTAR LA INFORMACION
from Crypto.Cipher import PKCS1_OAEP
#MODULO NECESARIO PARA ENCRIPTAR CON LA CLAVE PUBLICA

def make_pd(path, api, address):
#FUNCION EMPLEADA EN RECOGER LOS DATOS REGISTRADOS EN LOS DOCUMENTOS QUE SE
#ENCUENTRAN EN EL PATH, TRATARLOS ESTADISTICAMENTE Y LLAMAR A OTRA FUNCION
#ENCARGADA DE MANDAR LA TRANSACCION A LA RED.
    
 oldest = min(os.listdir(path), key=lambda f: os.path.getctime("{}/{}".format(path,f)))
 #FUNCION QUE ORDENA TODOS LOS DOCUMENTOS DE LA DIRECCION path SEGUN LA 
 #ANTIGUEDAD DE LOS MISMOS, EN TIEMPO UNIX, Y ESCOGE AL MENOR, ES DECIR, AL
 #MAS ANTIGUO. 
 
 path1=path+'/'+oldest
 #ESPECIFICA A NUESTRA DIRECCION EL NOMBRE DEL ARCHIVO QUE TIENE QUE ABRIR, EL
 #MAS ANTIGUO.
 #RECORDATORIO: SE HAN NOMBRADO LOS ARCHIVOS SEGUN EL UNIX TIME DE SU CREACION.
 
 db = open(path1,'r')
 data =db.read()
 db.close()
 #FUNCIONES QUE ABREN EL DOCUMENTO MAS ANTIGUO, GUARDAN LA INFORMACIÓN EN LA 
 #VARIABLE data COMO UN STRING, Y CIERRAN EL DOCUMENTO.
 
 data_dict=dict(eval(data))
 #CONVIERTE EL STRING EN UN DICCIONARIO CON LAS KEYS CORRECTAS, PERO COMO 
 #VALORES SE ENCUENTRA UNA LISTA DE STRINGS EN VEZ DE UNA LISTA DE VALORES
 #FLOAT, QUE ES COMO SON LAS MEDIDAS REALMENTE.
 
 for key in data_dict.keys():
 #POR CADA KEY DEL DICT...
  for value in data_dict.values():
  #POR CADA VALOR DE ESA KEY...
   for i in range(len(value)):
   #Y POR CADA ELEMENTO DE ESA CADENA DE STRINGS...
    data_dict[key][i]=float(data_dict[key][i])
    #CONVIERTE EL STRING EN UN FLOAT.
    
 data_df=pd.DataFrame(data_dict)
 #LA FUNCION DE PANDA DataFrame PERMITE CONVERTIR UN DICT EN UN OBJETO PANDA.
 #SE CARACTERIZA POR FUNCIONAR COMO UNA MATRIZ ( VER EN APARTADO 3.1), DONDE 
 #LAS FILAS LAS CONSTITUYE CADA KEY Y LAS COLUMNAS CADA MEDIDA TOMADA
 data_summary=data_df.describe([])
 #REALIZA UN RESUMEN ESTADISTICO CON LOS DATOS DE CADA FILA DE LA MATRIZ. 
 #PODRIAN EMPLEARSE METODOS MAS INTERESANTES, PERO DE ESTA MANERA PODEMOS 
 #OBTENER LA MEDIA DE CADA FILA DE FORMA RAPIDA.
 
 data_sent=[
 ["CLIENTE A:","I(A)mean:"+str(data_summary.iloc[1,0].round(3)),"V(V):"+str(data_summary.iloc[1,13].round(3)),"P(W)mean:"+str(data_summary.iloc[1,6].round(3))],
 ["CLIENTE B:","I(A)mean:"+str(data_summary.iloc[1,1].round(3)),"V(V):"+str(data_summary.iloc[1,14].round(3)),"P(W)mean:"+str(data_summary.iloc[1,7].round(3))],
 ["CLIENTE C:","I(A)mean:"+str(data_summary.iloc[1,2].round(3)),"V(V):"+str(data_summary.iloc[1,15].round(3)),"P(W)mean:"+str(data_summary.iloc[1,8].round(3))]
 ]
 #RECOPILA LAS MEDIAS DE LA INTENSIDAD, EL VOLTAJE Y LA POTENCIA, LAS REDONDEA
 #A 2 DECIMALES, Y LAS GUARDA EN LA LISTA DE LISTAS data_sent.

 send_iota(data_sent, data_summary, api, address)
 #LLAMADA A LA FUNCION send_iota PARA ENVIAR EL RESUMEN ESTADISTICO data_sent A
 #LA RED DE IOTA. SE ADJUNTA EL data_summary PARA DISPONER DEL TIEMPO DE LA 
 #ULTIMA TRANSACCION Y EL ACCESO api Y LA DIRECCIÓN A DONDE DIRIGIRLA.
 
 os.remove(path1)
 #UNA VEZ SE HA MANDADO CORRECTAMENTE LA INFORMACION, ESTA FUNCION BORRA DE 
 #LA RASPBERRY EL DOCUMENTO DONDE SE ENCONTRABAN LAS MEDIDAS DADO QUE NO NOS
 #INTERESA UTILIZAR LA RASPBERRY COMO BASE DE DATOS.

def send_iota(data_crypt, data_summary, api, address):
#FUNCION EMPLEADA PARA MANDAR LA TRANSACCION DE VALOR CERO A LA RED.
    
 data_def = ''
 #SE DECLARA UN STRING DONDE GUARDAREMOS CONSECUTIVAMENTE TODA LA INFORMACION
 #CIFRADA DE LOS CLIENTES. EL METODO DE ENCRIPTACION PERMITIRA SEPARARLO SIN 
 #PROBLEMAS, COMO SE VE EN ESTE APARTADO, EN Lectura de datos de la red.
 
 t0 = time.time()
 #REGISTRO DE TIEMPO PARA LLEVAR UN CONTROL DEL PROCESO
 
 for i in range(3):
 #BUCLE EMPLEADO PARA CIFRAR CON LA CLAVE PUBLICA DE CADA CLIENTE SU PARTE
 #CORRESPONDIENTE DE LA LISTA data_crypt, QUE SE HA DEFINIDO EN LA OTRA FUNCION.
 
     path = '/home/pi/Documents/FJavierGb/ULTIMATES/Public_Key'
     path1 = path + str(i)
     path2 = path1+'.py'
     #SISTEMA VASTO PARA ABRIR EL DOCUMENTO DONDE SE GUARDA LA LLAVE PUBLICA 
     #DE CADA CLIENTE DENTRO DE LA RASPBERRY. LA DIRECCION DEBE SER FIJA UNA 
     #VEZ SE IMPLANTE EL SISTEMA EN UN DISPOSITIVO.
     
     public_key = open(path2,'r')
     pubk = public_key.read()
     #FUNCIONES EMPLEADAS PARA ABRIR Y GUARDAR EN LA VARIABLE pubk LA CLAVE 
     #PUBLICA DEL CLIENTE ESPECIFICO EN CADA ITERACION.
     
     pubk1 = RSA.importKey(pubk)
     cipher1 = PKCS1_OAEP.new(pubk1)
     #FUNCIONES QUE PREPARAN EL ALGORITMO A UTILIZAR JUNTO A LA CLAVE PUBLICA
     #PARA ENCRIPTAR EL MENSAJE EN BYTES. VER APARTADO 3.3.
     
     data_crypt[i]= cipher1.encrypt(str(data_crypt[i]))
     #ENCRIPTA LA PARTE CORRESPONDIENTE DEL MENSAJE DE CADA CLIENTE CON SU 
     #CLAVE PUBLICA. PREVIAMENTE, TODA LA LISTA QUE CORRESPONDE A CADA CLIENTE
     #SE TRANSFORMA EN UNA STRING PARA PODER CONVERTIRSE CORRECTAMENTE EN BYTES.
     
     public_key.close()
     #SE CIERRA EL DOCUMENTO DONDE SE ENCUENTRA LA LLAVE PUBLICA
     
     data_def = data_def + data_crypt[i]
     #UNE TODAS LAS PARTES ENCRIPTADAS EN UNA UNICA
 
 api.send_transfer(
            transfers=[ProposedTransaction(
            address = Address(address[0]),
            message = TryteString.from_bytes(data_def),
            tag     = Tag(b'RPICTVFCOJAVIER'),
            value   = 0,
            timestamp = float(int(data_summary.iloc[5,12]))
                    )])
 #PAQUETE DE DATOS QUE ENVIAMOS AL NODO AL QUE ESTAMOS CONECTADOS. LOS ELEMENTOS
 #SE HAN EXPLICADO COMPLETAMENTE EN EL APARTADO 4.3. PERO CABE DESTACAR QUE
 #ES UNA TRANSACCION DE VALOR 0, QUE SE MANDA A NUESTRA PROPIA DIRECCION, QUE
 #SE EMPLEA UN TAG PROPIO DEL AUTOR Y QUE SE EMPLEA COMO TIMESTAMP LA FECHA
 #DE LA ULTIMA MEDIDA QUE SE TOMO DENTRO DEL DOCUMENTO.
 
 t1= time.time()
 #REGISTRO DE TIEMPO PARA LLEVAR UN CONTROL DEL PROCESO
 t2=t1-t0
 #DIFERENCIA ENTRE AMBOS REGISTROS, QUE INDICA EL TIEMPO QUE HA TARDADO EN 
 #REALIZARSE LA TRANSACCION.
 print('Enviado en:',t2)
 #MUESTRA POR PANTALLA ESTE TIEMPO.

def main():
#FUNCION PRINCIPAL. SIEMPRE SE LLAMA Y EXISTE PARA DAR MAYOR GRANULIDAD AL 
#SCRIPT, MEJORANDO SU ENTENDIMIENTO Y EL ANALISIS DE ERRORES
    
    SEED = 'KHVIEEVSFJNGFWANSVKNACCVABFEOTKSY9BYUEB99L9YLCJFZEPLUDNQO9QYBVYVWUIBDSPBTKXMYJMMX'
    #CLAVE PRIVADA DEL AUTOR EN IOTA. VER EL APARTADO 3.4. 
    
    NODE = 'https://nodes.thetangle.org:443'
    #NODO AL QUE VAMOS A CONECTARNOS Y ENVIAR LAS TRANSACCIONES. PARA SABER MAS
    #DE ESTE NODO, VER EL APARTADO 3.4. 
    #SE TRATA DEL NODO DE LA PAGINA thetangle.org.
    
    api = Iota(NODE, SEED)
    #FUNCION QUE CONECTA NUESTRA SEED AL NODO CON EL QUE VAMOS A TRABAJAR. NOS
    #INTERESA ESPECIALMENTE ESTE NODO PORQUE GUARDA LA INFORMACIÓN DE LAS 
    #TRANSACCIONES DE VALOR CERO INCLUSO TRAS LA REALIZACION DE UN SNAPSHOT (VER
    #APARTADO 3.4)

    address = [Address('XPVUPUY9XEHE9QKFNLVYFTITCTJQXXUOUEPVRBZBFXMLWBS9NNFWNIVQUROOCLHGIKAZKHYMQJPRCXRYX')]
    #SE TRATA DE LA DIRECCION A LA QUE SE VAN A ENVIAR LAS TRANSACCIONES DE VALOR
    #CERO (VER APARTADO 3.4.), PERTENECE A LA SEMILLA ANTERIOR. LA CREACION SE
    #EXPLICA EN EL APARTADO API DEL 3.4.
    
    path='/home/pi/Documents/FJavierGb/DATOSRPICTV'
    #ES UNA DIRECCION DE LA RASPBERRY QUE NO VA A MODIFICARSE. EN ESTA DIRECCION
    #SE GUARDAN PAQUETES DE DATOS CADA 10 SEGUNDOS, COMPUESTOS POR MEDIDAS 
    #PROVENIENTES DE LOS SENSORES TOMADAS CADA 2 SEGUNDOS.

    stop=False
    #PRIMER VALOR DE UN PARAMETRO DE CONTROL
    
    while stop==False:
    #BUCLE INFINITO QUE PERMITE EJECUTAR LA FUNCION INDEXADA EN EL TRY DE FORMA
    #INDEFINIDA O HASTA QUE INTERRUMPAMOS LA EJECUCION MEDIANTE UN COMANDO.
        try:
            make_pd(path, api, address)
            #LLAMADA A LA FUNCION make_pd PROPORCIONANDOLE COMO OUTPUTS EL path,
            #EL api Y LA address.
        except KeyboardInterrupt:
            #EL COMANDO DE INTERRUPCION ES PULSAR CUALQUIER TECLA. CUANDO SE
            #PULSA CUALQUIER TECLA, EL SISTEMA SE CIERRA, CORTANDO CUALQUIER
            #PROCESO Y EL BUCLE INFINITO SE CORTA.
            stop=True
            sys.exit()
            #FUNCION QUE INTERRUMPE CUALQUIER PROCESO Y TRATA DE CERRAR LA 
            #EJECUCION DEL SISTEMA. AL ENCONTRARSE EN UN BUCLE INFINITO, PARA
            #PODER CERRARSE CORRECTAMENTE, SE DEBE CERRAR EL BUCLE CON EL 
            #PARAMETRO DE CONTROL stop.

main()
#LLAMADA A FUNCION MAIN. SIEMPRE VA A OCURRIR; EL PROGRAMA SE ENCIERRA EN 
#FUNCIONES PARA MEJORAR EL CONTROL DEL SCRIPT




