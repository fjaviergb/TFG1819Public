import serial
#VER APARTADO 3.2 PARA SU EXPLICACION
import json
#VER APARTADO 3.1 PARA SU EXPLICACION
import time 
#VER APARTADO 3.1 PARA SU EXPLICACION
import paho.mqtt.client as mqtt
#VER APARTADO 3.3 PARA SU EXPLICACION

def main():
#FUNCION PRINCIPAL. SIEMPRE SE LLAMA Y EXISTE PARA DAR MAYOR GRANULIDAD AL 
#SCRIPT, MEJORANDO SU ENTENDIMIENTO Y EL ANALISIS DE ERRORES
    
    MQTT_BROKER = "localhost"
    #VARIABLE QUE GUARDA LA LOCALIZACION DEL SERVIDOR MQTT
    
    MQTT_TOPIC = "RPICT3V1"
    #VARIABLE QUE GUARDA EL TOPIC AL QUE SE VAN A DIRIGIR LOS MENSAJES
    
    QOS = 0
    #EL QOS (VER APARTADO 3.3) DE MENOR NIVEL PARA FAVORECER LA RAPIDEZ Y EL
    #RENDIMIENTO, SACRIFICANDO FIABILIDAD Y SEGURIDAD.
 
    client = mqtt.Client('Emisor',clean_session=True) 
    #FUNCION QUE DEFINE AL CLIENTE. EN ESTE CASO VAMOS A LLAMARLO EMISOR Y
    #LA UNICA PROPIEDAD QUE INTERESA ACLARAR ES EL CLEAN SESSION, PARA QUE
    #NO TRATE EL SERVIDOR DE GUARDAR MENSAJES CUANDO NO HAYA CLIENTES
    #ESPERANDOLOS

    client.connect(MQTT_BROKER, 1883, 60) #HOST + Puerto + KeepAlive; 
    #FUNCION QUE CONECTA AL CLIENTE CON EL SERVIDOR LOCAL, PREVIAMENTE INSTALADO
    #EN LA RASPBERRY. EL PUERTO ES EL DEDICADO A LA RED LOCAL Y SE INDICA 1
    #MINUTO PARA VERIFICAR LA CORRECTA CONEXIÓN ENTRE CLIENTE Y SERVIDOR.
    
    client.loop_start()
    #FUNCION QUE PERMITE AL CLIENTE MANTENERSE CONECTADO INDEFINIDAMENTE

    ser = serial.Serial('/dev/ttyAMA0', 38400)
    #FUNCION QUE PERMITE LA LECTURA DE LOS PUERTOS GPIO. SE ESPECIFICA LA
    #UART DEDICADO A ELLO Y EL BAUD RATE. VER APARTADO
    #3.2 PARA MÁS DETALLES.
    
    try:
    #BUCLE INFINITO QUE PERMITE LA RECEPCION CONSTANTE DE DATOS
       while 1:
       #AUTORIZACION CONSTANTE
            line = ser.readline()
            #GUARDADO EN LA VARIABLE line DE LAS MEDIDAS REALIZADAS COMO UNA
            #CADENA.
            line = line[:-2]
            #SE ELIMINAN LOS 2 ULTIMOS CARACTERES DE LA CADENA, QUE NO TIENEN
            #UTILIDAD PRACTICA
            Z=line.split(' ')
            #FUNCION QUE PERMITE DIVIDIR LA CADENA EN UNA LISTA, COGIENDO PARA
            #CADA TERMINO, TODA LA INFORMACIÓN COMPRENDIDA ENTRE DOS ESPACIOS,
            #REPRESENTADOS COMO ''
            
            if len(Z) > 15:
            #BUCLE QUE FILTRA POSIBLES MEDIDAS. LOS INPUTS SIEMPRE TENDRAN
            #16 TERMINOS, POR LO QUE MENOS TERMINOS SIGNIFICARA QUE ALGO ESTA
            #FALLANDO
            
                DATA = {
                        'TIME': [time.time()],
                        #MOMENTO DE REALIZACIN DE LA MEDIDA. NO PROVIENE DE 
                        #SENSORES
                        'P1(W)': [Z[1]],
                        #POTENCIA REAL MEDIDA DEL SENSOR 1. PROVIENE DE SENSORES
                        'S1(VA)': [Z[2]],
                        #POTENCIA APARENTE MEDIDA DEL SENSOR 1. CALCULADA A 
                        #PARTIR DEL VALOR EFICAZ DE LA INTENSIDAD Y EL VOLTAJE
                        'Irms1(A)': [Z[3]],
                        #INTENSIDAD EFICAZ MEDIDA. PROVIENE DEL SENSOR 1
                        'Vrms1(V)': [Z[4]],
                        #VOLTAJE EFICAZ MEDIDO. PROVIENE DEL SENSOR 1
                        'P.W1': [Z[5]],
                        #FACTOR DE POTENCIA DEL SENSOR 1. CALCULADA A PARTIR DE
                        #LA POTENCIA REAL Y LA POTENCIA APARENTE
                        'P2(W)': [Z[6]],
                        #POTENCIA REAL MEDIDA DEL SENSOR 2. PROVIENE DE SENSORES
                        'S2(VA)': [Z[7]],
                        #POTENCIA APARENTE MEDIDA DEL SENSOR 2. CALCULADA A 
                        #PARTIR DEL VALOR EFICAZ DE LA INTENSIDAD Y EL VOLTAJE
                        'Irms2(A)': [Z[8]],
                        #INTENSIDAD EFICAZ MEDIDA. PROVIENE DEL SENSOR 2
                        'Vrms2(V)': [Z[9]],
                        #VOLTAJE EFICAZ MEDIDO. PROVIENE DEL SENSOR 2
                        'P.W2': [Z[10]],
                        #FACTOR DE POTENCIA DEL SENSOR 2. CALCULADA A PARTIR DE
                        #LA POTENCIA REAL Y LA POTENCIA APARENTE
                        'P3(W)': [Z[11]],
                        #POTENCIA REAL MEDIDA DEL SENSOR 3. PROVIENE DE SENSORES
                        'S3(VA)': [Z[12]],
                        #POTENCIA APARENTE MEDIDA DEL SENSOR 3. CALCULADA A 
                        #PARTIR DEL VALOR EFICAZ DE LA INTENSIDAD Y EL VOLTAJE
                        'Irms3(A)': [Z[13]],
                        #INTENSIDAD EFICAZ MEDIDA. PROVIENE DEL SENSOR 3
                        'Vrms3(V)': [Z[14]],
                        #VOLTAJE EFICAZ MEDIDO. PROVIENE DEL SENSOR 3
                        'P.W3': [Z[15]],
                        #FACTOR DE POTENCIA DEL SENSOR 3. CALCULADA A PARTIR DE
                        #LA POTENCIA REAL Y LA POTENCIA APARENTE
                        }

                DATA_JSON = json.dumps(DATA)
                #FUNCION QUE TRANSFORMA LAS MEDIDAS OBTENIDAS, EN FORMATO DICT, A UN
                #FORMATO JSON, ADECUADO PARA SU ENVIO AL SERVIDOR MQTT.
       
            client.publish(MQTT_TOPIC, DATA_JSON, qos=QOS) 
            #FUNCION QUE PERMITE PUBLICAR LAS MEDIDAS DE LOS SENSORES AL TOPIC
            #ESPECIFICADO Y CON LA CALIDAD DE SERVICIO MINIMA.

    except KeyboardInterrupt:
    #EXCEPCION QUE INTERRUMPE EL BUCLE INFINITO DE TRY Y, POR TANTO, EL WHILE.
        ser.close()
        #FUNCION QUE CORTA EL USO DEL MICROCONTROLADOR.
        
main()
#LLAMADA A FUNCION MAIN. SIEMPRE VA A OCURRIR; EL PROGRAMA SE ENCIERRA EN 
#FUNCIONES PARA MEJORAR EL CONTROL DEL SCRIPT
